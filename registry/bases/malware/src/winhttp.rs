#[cfg(windows)]
pub fn get_public_ip_winhttp() -> Option<String> {
    use windows_sys::Win32::Networking::WinHttp::{
        WinHttpOpen, WinHttpConnect, WinHttpOpenRequest, WinHttpSendRequest,
        WinHttpReceiveResponse, WinHttpReadData, WinHttpCloseHandle,
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_FLAG_SECURE,
    };

    fn pwstr(s: &str) -> Vec<u16> {
        use std::os::windows::ffi::OsStrExt;
        std::ffi::OsStr::new(s).encode_wide().chain(std::iter::once(0)).collect()
    }

    unsafe {
        let agent = pwstr("learninghub/1.0");
        let h_session = WinHttpOpen(
            agent.as_ptr(),
            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
            std::ptr::null(),
            std::ptr::null(),
            0,
        );
        if h_session.is_null(){
            return None;
        }

        let host = pwstr("ipv4.myip.wtf");
        let h_connect = WinHttpConnect(h_session, host.as_ptr(), 443, 0);
        if h_connect.is_null() {
            WinHttpCloseHandle(h_session);
            return None;
        }

        let verb = pwstr("GET");
        let target = pwstr("/text");
        let h_request = WinHttpOpenRequest(
            h_connect,
            verb.as_ptr(),
            target.as_ptr(),
            std::ptr::null(),
            std::ptr::null(),
            std::ptr::null_mut(),
            WINHTTP_FLAG_SECURE,
        );
        if h_request.is_null() {
            WinHttpCloseHandle(h_connect);
            WinHttpCloseHandle(h_session);
            return None;
        }

        let ok = WinHttpSendRequest(
            h_request,
            std::ptr::null(),
            0,
            std::ptr::null_mut(),
            0,
            0,
            0,
        );
        if ok == 0 {
            WinHttpCloseHandle(h_request);
            WinHttpCloseHandle(h_connect);
            WinHttpCloseHandle(h_session);
            return None;
        }

        let ok = WinHttpReceiveResponse(h_request, std::ptr::null_mut());
        if ok == 0 {
            WinHttpCloseHandle(h_request);
            WinHttpCloseHandle(h_connect);
            WinHttpCloseHandle(h_session);
            return None;
        }

        let mut buf = Vec::<u8>::new();
        loop {
            let mut read: u32 = 0;
            let mut chunk = vec![0u8; 4096];
            let ok = WinHttpReadData(
                h_request,
                chunk.as_mut_ptr() as *mut _,
                chunk.len() as u32,
                &mut read,
            );
            if ok == 0 || read == 0 {
                break;
            }
            buf.extend_from_slice(&chunk[..read as usize]);
            if read < chunk.len() as u32 {
                break;
            }
        }

        WinHttpCloseHandle(h_request);
        WinHttpCloseHandle(h_connect);
        WinHttpCloseHandle(h_session);

        if buf.is_empty() {
            None
        } else {
            let s = String::from_utf8_lossy(&buf).trim().to_string();
            if s.is_empty() { None } else { Some(s) }
        }
    }
}

#[cfg(not(windows))]
pub fn get_public_ip_winhttp() -> Option<String> {
    None
}
