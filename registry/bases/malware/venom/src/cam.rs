#![cfg(target_os = "windows")]

use std::{ptr, path::Path};
use std::os::windows::ffi::OsStrExt;

use windows::{
    core::{GUID, PCWSTR, Result},
    Win32::{
        Foundation::BOOL,
        Graphics::GdiPlus::*,
        Media::MediaFoundation::*,
    },
};

fn png_clsid() -> GUID {
    GUID::from_values(
        0x557CF406,
        0x1A04,
        0x11D3,
        [0x9A, 0x73, 0x00, 0x00, 0xF8, 0x1E, 0xF3, 0x2E],
    )
}

const PIXEL_FORMAT_32BPP_ARGB: u32 = 0x26200A;

fn nv12_to_rgb(nv12_data: &[u8], width: u32, height: u32) -> Vec<u8> {
    let mut rgb = vec![0u8; (width * height * 4) as usize];
    let y_plane_size = (width * height) as usize;
    let uv_plane_offset = y_plane_size;
    
    for y in 0..height {
        for x in 0..width {
            let y_idx = (y * width + x) as usize;
            if y_idx >= y_plane_size {
                continue;
            }
            
            let y_val = nv12_data[y_idx] as i32;
            let uv_row = y / 2;
            let uv_col = (x / 2) * 2;
            let uv_idx = uv_plane_offset + (uv_row * width + uv_col) as usize;
            
            if uv_idx + 1 >= nv12_data.len() {
                continue;
            }
            
            let u = nv12_data[uv_idx] as i32 - 128;
            let v = nv12_data[uv_idx + 1] as i32 - 128;
            
            let rgb_idx = (y * width + x) as usize * 4;
            if rgb_idx + 3 >= rgb.len() {
                continue;
            }
            
            let r = (y_val + (1.402 * v as f32) as i32).clamp(0, 255) as u8;
            let g = (y_val - (0.344 * u as f32) as i32 - (0.714 * v as f32) as i32).clamp(0, 255) as u8;
            let b = (y_val + (1.772 * u as f32) as i32).clamp(0, 255) as u8;
            
            rgb[rgb_idx] = b;
            rgb[rgb_idx + 1] = g;
            rgb[rgb_idx + 2] = r;
            rgb[rgb_idx + 3] = 255;
        }
    }
    
    rgb
}

fn yuy2_to_rgb(yuy2_data: &[u8], width: u32, height: u32) -> Vec<u8> {
    let mut rgb = vec![0u8; (width * height * 4) as usize];
    
    for y in 0..height {
        for x in 0..(width / 2) {
            let yuy2_idx = ((y * width * 2) + (x * 4)) as usize;
            if yuy2_idx + 3 >= yuy2_data.len() {
                break;
            }
            
            let y0 = yuy2_data[yuy2_idx] as i32;
            let u = yuy2_data[yuy2_idx + 1] as i32 - 128;
            let y1 = yuy2_data[yuy2_idx + 2] as i32;
            let v = yuy2_data[yuy2_idx + 3] as i32 - 128;
            
            let rgb_idx = ((y * width + x * 2) * 4) as usize;
            if rgb_idx + 3 < rgb.len() {
                let r = (y0 + (1.402 * v as f32) as i32).clamp(0, 255) as u8;
                let g = (y0 - (0.344 * u as f32) as i32 - (0.714 * v as f32) as i32).clamp(0, 255) as u8;
                let b = (y0 + (1.772 * u as f32) as i32).clamp(0, 255) as u8;
                
                rgb[rgb_idx] = b;
                rgb[rgb_idx + 1] = g;
                rgb[rgb_idx + 2] = r;
                rgb[rgb_idx + 3] = 255;
            }
            
            let rgb_idx2 = ((y * width + x * 2 + 1) * 4) as usize;
            if rgb_idx2 + 3 < rgb.len() {
                let r = (y1 + (1.402 * v as f32) as i32).clamp(0, 255) as u8;
                let g = (y1 - (0.344 * u as f32) as i32 - (0.714 * v as f32) as i32).clamp(0, 255) as u8;
                let b = (y1 + (1.772 * u as f32) as i32).clamp(0, 255) as u8;
                
                rgb[rgb_idx2] = b;
                rgb[rgb_idx2 + 1] = g;
                rgb[rgb_idx2 + 2] = r;
                rgb[rgb_idx2 + 3] = 255;
            }
        }
    }
    
    rgb
}

pub fn capture_camera(path: &Path) -> Result<bool> {
    unsafe {
        let mut token = 0;
        let startup_input = GdiplusStartupInput {
            GdiplusVersion: 1,
            DebugEventCallback: 0,
            SuppressBackgroundThread: BOOL(0),
            SuppressExternalCodecs: BOOL(0),
        };
        GdiplusStartup(&mut token, &startup_input, ptr::null_mut());

        MFStartup(MF_VERSION, MFSTARTUP_LITE)?;

        let mut attributes: Option<IMFAttributes> = None;
        MFCreateAttributes(&mut attributes, 1)?;
        let attributes = attributes.unwrap();
        attributes.SetGUID(
            &MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE,
            &MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID,
        )?;

        let mut pp_devices: *mut Option<IMFActivate> = ptr::null_mut();
        let mut count = 0u32;
        
        MFEnumDeviceSources(&attributes, &mut pp_devices, &mut count)?;

        if count == 0 || pp_devices.is_null() {
            MFShutdown()?;
            GdiplusShutdown(token);
            return windows::core::Result::Ok(false);
        }
        
        let first_device_opt = &*pp_devices;
        if first_device_opt.is_none() {
            MFShutdown()?;
            GdiplusShutdown(token);
            return windows::core::Result::Ok(false);
        }
        
        let first_camera = first_device_opt.as_ref().unwrap();
        let media_source: IMFMediaSource = match first_camera.ActivateObject() {
            Result::Ok(ms) => ms,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };

        let mut reader_attr: Option<IMFAttributes> = None;
        MFCreateAttributes(&mut reader_attr, 1)?;
        let reader_attr = reader_attr.as_ref().unwrap();
        reader_attr.SetUINT32(&MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, 1)?;

        let reader: IMFSourceReader = match MFCreateSourceReaderFromMediaSource(&media_source, Some(reader_attr)) {
            Result::Ok(r) => r,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };

        let media_type: IMFMediaType = match reader.GetCurrentMediaType(MF_SOURCE_READER_FIRST_VIDEO_STREAM.0 as u32) {
            Result::Ok(mt) => mt,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };

        let frame_size: u64 = match media_type.GetUINT64(&MF_MT_FRAME_SIZE) {
            Result::Ok(fs) => fs,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };
        let width = (frame_size >> 32) as u32;
        let height = (frame_size & 0xFFFFFFFF) as u32;

        let subtype = match media_type.GetGUID(&MF_MT_SUBTYPE) {
            Result::Ok(st) => st,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };

        let mut sample: Option<IMFSample> = None;
        
        for _ in 1..=10 {
            let mut actual_stream_index: u32 = 0;
            let mut stream_flags: u32 = 0;
            let mut timestamp: i64 = 0;
            
            match reader.ReadSample(
                MF_SOURCE_READER_FIRST_VIDEO_STREAM.0 as u32,
                0,
                Some(&mut actual_stream_index),
                Some(&mut stream_flags),
                Some(&mut timestamp),
                Some(&mut sample),
            ) {
                Result::Ok(_) => {
                    if sample.is_some() {
                        break;
                    }
                    std::thread::sleep(std::time::Duration::from_millis(100));
                }
                Err(_) => {
                    MFShutdown()?;
                    GdiplusShutdown(token);
                    return windows::core::Result::Ok(false);
                }
            }
        }

        if sample.is_none() {
            MFShutdown()?;
            GdiplusShutdown(token);
            return windows::core::Result::Ok(false);
        }

        let sample = sample.unwrap();
        let buffer: IMFMediaBuffer = match sample.ConvertToContiguousBuffer() {
            Result::Ok(buf) => buf,
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        };

        let mut data_ptr: *mut u8 = ptr::null_mut();
        let mut max_len: u32 = 0;
        let mut current_len: u32 = 0;
        
        match buffer.Lock(&mut data_ptr, Some(&mut max_len), Some(&mut current_len)) {
            Result::Ok(_) => {},
            Err(_) => {
                MFShutdown()?;
                GdiplusShutdown(token);
                return windows::core::Result::Ok(false);
            }
        }
        
        if data_ptr.is_null() {
            buffer.Unlock()?;
            MFShutdown()?;
            GdiplusShutdown(token);
            return windows::core::Result::Ok(false);
        }
        
        let frame_data = std::slice::from_raw_parts(data_ptr, current_len as usize).to_vec();
        buffer.Unlock()?;

        let is_nv12 = subtype.data1 == 0x3231564E;
        let rgb_data = if is_nv12 {
            nv12_to_rgb(&frame_data, width, height)
        } else {
            yuy2_to_rgb(&frame_data, width, height)
        };
        
        let stride = (width * 4) as i32;
        let mut bmp: *mut GpBitmap = ptr::null_mut();
        let status = GdipCreateBitmapFromScan0(
            width as i32,
            height as i32,
            stride,
            PIXEL_FORMAT_32BPP_ARGB as i32,
            Some(rgb_data.as_ptr()),
            &mut bmp,
        );

        if status != Status(0) || bmp.is_null() {
            MFShutdown()?;
            GdiplusShutdown(token);
            return windows::core::Result::Ok(false);
        }

        let wide: Vec<u16> = path.as_os_str().encode_wide().chain(Some(0)).collect();
        let pcwstr = PCWSTR(wide.as_ptr());
        
        let save_status = GdipSaveImageToFile(bmp as *mut GpImage, pcwstr, &png_clsid(), ptr::null_mut());

        GdipDisposeImage(bmp as *mut GpImage);

        let devices_slice = std::slice::from_raw_parts(pp_devices, count as usize);
        for device_opt in devices_slice {
            if let Some(device) = device_opt {
                let _ = device.ShutdownObject();
            }
        }

        MFShutdown()?;
        GdiplusShutdown(token);

        windows::core::Result::Ok(save_status == Status(0))
    }
}